#!/usr/bin/env node

const path = require('path')
const program = require('commander')
const boxen = require('boxen')
const chalk = require('chalk')
const fse = require('fs-extra')
const ejs = require('ejs')
const {cd, exec, which} = require('shelljs')
const hasYarn = () => Boolean(which('yarn'))

program
  .option('-p, --package', 'Adds a package.json to your export.')
  .option('-d, --development', 'Enable development mode.')
  .action(() => exportApp({package: program.package, development: program.development}))
  .parse(process.argv)

if(!program.args.length) exportApp(program.opts())

function exportApp({package, development}) {
  if(!development) process.env.NODE_ENV = 'production'

  const webpack = require('webpack')
  const ProgressPlugin = require('webpack/lib/ProgressPlugin')
  const webpackConfig = require('../webpack.config')

  const projectDir = process.cwd()
  const buildsDir = `${projectDir}/dist`
  webpackConfig.output = { path: buildsDir }

  fse.removeSync(buildsDir)
  const compiler = webpack(webpackConfig)
  process.stderr.write('\x1B[?25l')

  compiler.apply(new ProgressPlugin((percentage, msg) => {
    const percent = (percentage * 100).toFixed(2)
    process.stdout.cursorTo(0)
    process.stdout.clearLine()
    process.stdout.write(chalk.gray(`${percent}% exported`))
  }))

  compiler.run((err, stats) => {
    const appConfig = require(path.resolve(projectDir, 'package.json'))

    process.stderr.write('\x1B[?25h')
    if(err) return console.error(chalk.red(err.message))

    Promise.resolve()
    .then(() => {
      if(!package) return Promise.resolve();
      return fse.outputFile(path.resolve(buildsDir, 'package.json'), createPackageTmpl({name: appConfig.name}))
    })
    .then(() => createHtmlTmpl({isProd: !development, name: appConfig.name, description: appConfig.description, title: appConfig.name}))
    .then(data => fse.outputFile(path.resolve(buildsDir, 'index.html'), data))
    .then(() => fse.copy(path.resolve(__dirname, './../sw.js'), path.resolve(buildsDir, 'sw.js')))
    .then(() => fse.copy(path.resolve(projectDir, 'static'), path.resolve(buildsDir)))
    .then(() => package ? install({path: buildsDir}) : Promise.resolve())
    .then(() => {
      process.stdout.cursorTo(0)
      process.stdout.clearLine()

      let message = chalk.green('SPA/PWA export to\n\n')
      message += chalk.gray(`${buildsDir}\n`)
      message += chalk.green('\ncompleted!\n')

      console.log(boxen(message, {padding: 1, borderColor: 'gray', margin: 1}));
    })
    .catch(error => console.error(chalk.red(`\n${error.message}`)))
  })
}

function createPackageTmpl ({name, nodeVersion = 6}) {
  return `{
  "private": true,
  "name": "${name}",
  "version": "0.0.0",
  "description": "My ${name} React-SPA-App",
  "engines": {
    "node": "^${nodeVersion}"
  },
  "scripts": {
    "dev": "NODE_ENV=development http-server ./ --push-state -c-1",
    "start": "NODE_ENV=production http-server ./ --push-state --silent --p 80"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "http-server": "^0.10.0",
    "spa-http-server": "^0.9.0"
  }
}`
}

function createHtmlTmpl ({name, title, description, isProd, css, html}) {
  const htmlFilePath = path.resolve(__dirname, './../views/index.ejs');

  return fse
  .readFile(htmlFilePath)
  .then(data => ejs.render(data.toString(), {title, description, name, IS_PROD: isProd, css, html}))
}

function install ({path}) {
  return new Promise((resolve, reject) => {
    cd(path)
    const installCmd = hasYarn() ? 'yarn' : 'npm install'

    exec(installCmd, (code, stdout, stderr) => {
      if (code !== 0) return reject(stderr)
      resolve()
    })
  })
}